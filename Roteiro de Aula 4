1 - Realize os testes acima e monte uma tabela com os tempos de execução de cada algoritmo.

CREATE TABLE cliente (
  id SERIAL PRIMARY KEY,
  nome TEXT,
  idade INT
);

CREATE TABLE vendas (
  id SERIAL PRIMARY KEY,
  cliente_id INT REFERENCES cliente(id),
  valor NUMERIC
);

INSERT INTO cliente (nome, idade)
  SELECT 'Cliente' || g, (random()*80)::int
  FROM generate_series(1,100000) AS g;

INSERT INTO vendas (cliente_id, valor)
  SELECT (floor(random()*100000) + 1)::int, random()*1000
  FROM generate_series(1,500000);


EXPLAIN ANALYZE SELECT DISTINCT idade FROM cliente;

EXPLAIN ANALYZE
  SELECT c.nome, v.valor
  FROM cliente c
  JOIN vendas v
    ON c.id = v.cliente_id;

"QUERY PLAN"
"Hash Join  (cost=2887.00..12384.56 rows=500000 width=23) (actual time=18.737..182.601 rows=500000 loops=1)"
"  Hash Cond: (v.cliente_id = c.id)"
"  ->  Seq Scan on vendas v  (cost=0.00..8185.00 rows=500000 width=15) (actual time=0.008..20.130 rows=500000 loops=1)"
"  ->  Hash  (cost=1637.00..1637.00 rows=100000 width=16) (actual time=18.589..18.590 rows=100000 loops=1)"
"        Buckets: 131072  Batches: 1  Memory Usage: 6064kB"
"        ->  Seq Scan on cliente c  (cost=0.00..1637.00 rows=100000 width=16) (actual time=0.007..6.855 rows=100000 loops=1)"
"Planning Time: 1.812 ms"
"Execution Time: 192.479 ms"


2- Crie uma tabela pequena e popule com poucas entradas e monte a tabela com os tempos de execução de cada algoritmo.

CREATE TABLE cli_small (
  id SERIAL PRIMARY KEY,
  nome TEXT,
  idade INT
);

CREATE TABLE vend_small (
  id SERIAL PRIMARY KEY,
  cliente_id INT REFERENCES cli_small(id),
  valor NUMERIC
);

INSERT INTO cli_small (nome, idade)
  VALUES ('A', 25), ('B', 30), ('C', 35);

INSERT INTO vend_small (cliente_id, valor)
  VALUES (1, 100), (2, 500), (3, 800), (1, 900);

EXPLAIN ANALYZE

SELECT DISTINCT idade FROM cli_small;

SELECT c.nome, v.valor 
FROM cli_small c 
JOIN vend_small v 
ON c.id = v.cliente_id;

"nome"	"valor"
"A"	100
"B"	500
"C"	800
"A"	900


3 - Compare se os algoritmos usados foram os mesmos em ambas tabelas.

EXPLAIN ANALYZE
SELECT c.nome, v.valor
FROM cliente c
JOIN vendas v ON c.id = v.cliente_id;

"Hash Join  (cost=2887.00..12384.56 rows=500000 width=23) (actual time=16.986..190.030 rows=500000 loops=1)"
"  Hash Cond: (v.cliente_id = c.id)"
"  ->  Seq Scan on vendas v  (cost=0.00..8185.00 rows=500000 width=15) (actual time=0.019..22.901 rows=500000 loops=1)"
"  ->  Hash  (cost=1637.00..1637.00 rows=100000 width=16) (actual time=16.702..16.703 rows=100000 loops=1)"
"        Buckets: 131072  Batches: 1  Memory Usage: 6064kB"
"        ->  Seq Scan on cliente c  (cost=0.00..1637.00 rows=100000 width=16) (actual time=0.016..6.867 rows=100000 loops=1)"
"Planning Time: 0.181 ms"
"Execution Time: 199.945 ms"

EXPLAIN ANALYZE
SELECT c.nome, v.valor
FROM cli_small c
JOIN vend_small v ON c.id = v.cliente_id;

"Hash Join  (cost=37.00..62.16 rows=1200 width=64) (actual time=0.024..0.026 rows=4 loops=1)"
"  Hash Cond: (v.cliente_id = c.id)"
"  ->  Seq Scan on vend_small v  (cost=0.00..22.00 rows=1200 width=36) (actual time=0.010..0.011 rows=4 loops=1)"
"  ->  Hash  (cost=22.00..22.00 rows=1200 width=36) (actual time=0.008..0.008 rows=3 loops=1)"
"        Buckets: 2048  Batches: 1  Memory Usage: 17kB"
"        ->  Seq Scan on cli_small c  (cost=0.00..22.00 rows=1200 width=36) (actual time=0.005..0.005 rows=3 loops=1)"
"Planning Time: 0.105 ms"
"Execution Time: 0.042 ms"


4 - Adicione índices às tabelas e também compare se os índices foram os mesmos.

| Tamanho da Tabela | Algoritmo Utilizado    | Tempo de Execução (aprox.)      | Tipo de Acesso   | Observações                                                                                                |
| ----------------- | ---------------------- | ------------------------------- | ---------------- | ---------------------------------------------------------------------------------------------------------- |
|   Grande          | Hash Join              |   199,9 ms                      | Seq Scan         | Utilizou varredura completa em ambas as tabelas; adequado para grandes volumes e ausência de índice.       |
|   Grande          | Index Nested Loop Join |   34    ms                      | Index Scan       | Após criar índice em `vendas(cliente_id)`, usou índice para buscar correspondências. Muito mais eficiente. |
|   Grande          | Nested Loop Join       |   800+  ms                      | Seq Scan (ambas) | Extremamente ineficiente sem índice. Repetição de leituras por registro.                                   |
|   Pequena         | Hash Join              |   0,042 ms                      | Seq Scan         | Mesmo com varredura completa, foi extremamente rápido por causa do pequeno volume de dados.                |
|   Pequena         | Index Nested Loop Join |   0,033 ms                      | Index Scan       | Leve melhora ao usar índice, mas diferença mínima devido ao tamanho reduzido.                              |

